\documentclass[a4paper,10pt]{article}\usepackage{graphicx}\usepackage{wasysym}\title{Threads Extension for NachOS for Java}\author{Zsolt Istv\'{a}n, Bal\'{a}zs Karsay, Robert Mynio, Istv\'{a}n Szak\'{a}ts}\date{October 2, 2010}\begin{document}\maketitle\section{Introduction}%Write a bit about deficiencies of the current modelFrom a scheduling point of view ... necessity for priority donation...\section{Alarm clock}% WHO?\section{Synchronization}% WHO?\section{Priority scheduler}\subsection{Problem description}Our task is to implement a priority scheduler in NachOS by completing the PriorityScheduler class. Priority scheduling is an important detail in any real operating system. The basic idea behind priority scheduling is that in choosing which thread to dequeue, the scheduler should always choose the thread with the highest effective priority. If multiple threads with the same highest priority are waiting in the queue, the scheduler should choose the one that has been waiting the longest.An issue which we have to deal with is priority inversion. If a high priority thread needs to wait for a low priority thread (for instance, for a lock held by a low priority thread), and another high priority thread is on the ready list, then the high priority thread will never get the CPU because the low priority thread will not get any CPU time. Based on the techniques learned at class we decided to solve this issue by using priority donation. That is, to have the waiting thread donate its priority to one which is holding the lock, so this one can execute and release the lock.The current implementation does not deal with the concept of priority, so in order to be able to use the above presented algorithm, we have to extend the notion of a thread. This will be done by including a thread's priority (something that is decided at creation) and a way for deciding its effective priority (which reflects the results of priority donation among threads).\subsection{The ThreadState} A thread's effective priority can be cached in its ThreadState. When the threads in a ThreadQueue change, the effective priority of its owner, say thread A, may also change and may need to be updated.  This will go on .... So updating effective priority is a propagation of these changes.As described before we will have to wrap the KThread objects in a more complex data structure so the system can associate with each thread additional info necessary for priority scheduling. This is what the ThreadState class is for, and these are its most important properties:\begin{itemize}\item priority - which is an integer showing how important a thread is in the system\item effective priority - this value overrides the priority temporarily in case of priority donation, and is cached \item owned queue - this is a reference to the lock whose queue this thread has acquired\end{itemize}From an implementation point of view, it will contain the following methods:\begin{itemize}\item \texttt{get/setPriority()} methods will be used to set and get the priority of the underlying thread.\item \texttt{get/setEffectivePriority()} will be used in the priority donation algorithm together with the \texttt{refreshEffectivePriority()} which will make sure that the effective priority is up to date in a case of waiting for access on a lock. As an example, one could have a thread A that may be added into another ThreadQueue which may have an owner, thread B, and this change may cause B's effective priority to change as well. One has to make sure that this change is correctly propagated.\item \texttt{acquire(queue)} and \texttt{rewokeOwnership()} pair will help setting and clearing the ``owned queue'' mentioned above, and they will be called from the PriorityQueue, whenever it changes owners.\end{itemize}\subsection{The PriorityQueue}PriorityQueue, basically any ThreadQueue, implements the scheduling of threads waiting for accessing any resource, be it the CPU or a lock. There will be a PriorityQueue for each resource. At any time a thread is in exactly one queue (waiting for accessing a resource). Each resource can be held by at most one thread, which we call the owner of that resource (this ownership is referenced also from the ThreadState). Since each resource is associated with one ThreadQueue, the owner of the resource is also called the owner of the ThreadQueue that is waiting for this resource.As with any queue the most important detail of PriorityQueue is the way it gives us the next element, which in our case is based on the priority of the threads. In the following we present the pseudocode for selecting the next thread from the queue:\begin{verbatim}BEGIN selectNext()  IF queue.empty THEN     RETURN null   END IF  priority = priority.MAX  WHILE (queue.getFifo(priority).empty) DO    priority--  END WHILE  fifo = queue.getFifo(priority)  RETURN fifo.removeNextEND\end{verbatim}And the method for inserting a new element into the waiting queue can be described as:\begin{verbatim}BEGIN insert(thread)  IF NOT EXIST queue.getFifo(thread.priority) THEN     queue.createFifo(thread.priority)   END IF  queue.getFifo(thread.priority).add(thread)END\end{verbatim}%bullshit from here------------------------------------------------------------------------------------------------%effective priority relatedA ThreadQueue changes when a thread is added to or removed from the queue or one of its members acquires another queue. These happen in places such as waitForAccess,  acquire, nextThread . These are the places when effective priorities may change. Note in nextThread when a new thread is selected to hold the resource, the previous owner does not own this queue anymore and this may change its effective priority, which in turn may cause the propagation described above. Think about what information you need in PriorityQueue and ThreadState to perform this update and remember a thread can own multiple ThreadQueues.We will implement the methods getPriority(), getEffectivePriority(), and setPriority(). You may optionally also implement increasePriority() and decreasePriority() (these are not required). Implement the priority scheduler so that it donates priority, where possible. Be sure to implement Scheduler.getEffectivePriority(), which returns the priority of a thread after taking into account all the donations it is receiving.Note that while solving the priority donation problem, you will find a point where you can easily calculate the effective priority for a thread, but this calculation takes a long time. To receive full credit for the design aspect of this project, you need to speed this up by caching the effective priority and only recalculating a thread's effective priority when it is possible for it to change.It is important that you do not break the abstraction barriers while doing this part -- the Lock class does not need to be modified. Priority donation should be accomplished by creating a subclass of ThreadQueue that will accomplish priority donation when used with the existing Lock class, and still work correctly when used with the existing Semaphore and Condition classes.\end{document}