\documentclass[a4paper,10pt]{article}\usepackage{graphicx}\usepackage{wasysym}\title{Threads Extension for NachOS Implemented~in~Java}\author{Zsolt Istv\'{a}n, Bal\'{a}zs Karsay, Robert Mynio, Istv\'{a}n Szak\'{a}ts}\date{October 2, 2010}\begin{document}\maketitle\section{Introduction}%Write a bit about deficiencies of the current model???\section{Alarm Clock}% WHO?\section{Synchronization}% WHO?\section{Priority Scheduling}\subsection{Problem description}Our task is to implement a priority scheduler in NachOS by completing the PriorityScheduler class. Priority scheduling is an important detail in any real operating system. The basic idea behind priority scheduling is that in choosing which thread to dequeue, the scheduler should always choose the thread with the highest effective priority. If multiple threads with the same highest priority are waiting in the queue, the scheduler should choose the one that has been waiting the longest.An issue which we have to deal with is priority inversion. If a high priority thread needs to wait for a low priority thread (for instance, for a lock held by a low priority thread), and another high priority thread is on the ready list, then the high priority thread will never get the CPU because the low priority thread will not get any CPU time. Based on the techniques learned at class we decided to solve this issue by using priority donation. That is, to have the waiting thread donate its priority to one which is holding the lock, so this one can execute and release the lock.The current implementation does not deal with the concept of priority, so in order to be able to use the above presented algorithm, we have to extend the notion of a thread. This will be done by including a thread's priority (something that is decided at creation) and a way for deciding its effective priority (which reflects the results of priority donation among threads).\subsection{The ThreadState} A thread's effective priority can be cached in its ThreadState. When the threads in a ThreadQueue change, the effective priority of its owner, say thread A, may also change and may need to be updated.  This will go on .... So updating effective priority is a propagation of these changes.As described before we will have to wrap the KThread objects in a more complex data structure so the system can associate with each thread additional info necessary for priority scheduling. This is what the ThreadState class is for, and these are its most important properties:\begin{itemize}\item priority - which is an integer showing how important a thread is in the system\item effective priority - this value overrides the priority temporarily in case of priority donation, and is cached \item owned queue - this is a reference to the lock whose queue this thread has acquired\end{itemize}From an implementation point of view, it will contain the following methods:\begin{itemize}\item \texttt{get/setPriority()} methods will be used to set and get the priority of the underlying thread.\item \texttt{get/setEffectivePriority()} will be used in the priority donation algorithm together with the \texttt{refreshEffectivePriority()} which will make sure that the effective priority is up to date in a case of waiting for access on a lock. As an example, one could have a thread A that may be added into another ThreadQueue which may have an owner, thread B, and this change may cause B's effective priority to change as well. One has to make sure that this change is correctly propagated.\item \texttt{acquire(queue)} and \texttt{rewokeOwnership()} pair will help setting and clearing the ``owned queue'' mentioned above, and they will be called from the PriorityQueue, whenever it changes owners.\end{itemize}\subsection{The PriorityQueue}PriorityQueue, basically any ThreadQueue, implements the scheduling of threads waiting for accessing any resource, be it the CPU or a lock. There will be a PriorityQueue for each resource. At any time a thread is in exactly one queue (waiting for accessing a resource). Each resource can be held by at most one thread, which we call the owner of that resource (this ownership is referenced also from the ThreadState). Since each resource is associated with one ThreadQueue, the owner of the resource is also called the owner of the ThreadQueue that is waiting for this resource.As with any queue the most important detail of PriorityQueue is the way it gives us the next element, which in our case is based on the priority of the threads. In the following we present the pseudocode for selecting the next thread from the queue:\begin{verbatim}BEGIN selectNext()  IF queue.empty THEN     RETURN null   END IF  priority = priority.MAX  WHILE (queue.getFifo(priority).empty) DO    priority--  END WHILE  fifo = queue.getFifo(priority)  RETURN fifo.removeNextEND\end{verbatim}And the method for inserting a new element into the waiting queue can be described as:\begin{verbatim}BEGIN insert(thread)  IF NOT EXIST queue.getFifo(thread.priority) THEN     queue.createFifo(thread.priority)   END IF  queue.getFifo(thread.priority).add(thread)END\end{verbatim}In order to accomplish the tasks presented above, the ThreadQueue must be subclassed in order to represent additional information required by the priority donation algorithm. The PriorityQueue subclass will contain the following additional properties and data structures:\begin{itemize}\item owner thread - a KThread which is the owner of the PriorityQueue instance.\item waiting threads - this is a HashMap data structure that associates a list of ThreadStates with a given priority.\item priority transfer flag - a boolean which specifies if the owner thread should receive a priority from a waiting thread (priority donation).\end{itemize}From an implementation point of view, it will contain the following methods:\begin{itemize}\item \texttt{getOwnerThreadState()} returns the ThreadState of the owner thread (myThread).\item \texttt{putToWait(ThreadState)/removeFromWait(ThreadState)} pair will be used to add/remove a ThreadState and its associated priority to the HashMap. If a list with the respective priority does not yet exist, it will be created and the ThreadState will be inserted into the list. \item \texttt{acquire(thread)} is used to set the owner of a PriorityQueue.\item \texttt{peekNextThread()} method returns the Thread that \texttt{nextThread()} would return, but it does not change the state and contents of the queue.\item \texttt{nextThread()} selects extracts the next Thread from the queue based on its priority (the thread with the highest priority will be extracted). This method is called when we need to context switch to another thread. We also use this method to restore the effective priority to be equal to its actual priority in case it was changed due priority.\end{itemize}\subsection{Testing}In order to test the functionality of the PriorityScheduler, the following test cases should be implemented:\begin{enumerate}\item no donation - test with at least three Threads with different priorities and no locks. Thus, no priority donation is necessary.\item simple donation - simple priority donation test with three Threads and one lock. A mid-priority Thread that doesn't deal with any locks, a low-priority Thread that deals with the lock and a hi-priority Thread that also deals with the lock. First, the low-priority Thread acquires the lock. Then hi-priority Thread should also acquire the lock. If the priority donation is not implemented correctly, only the hi-priority Thread will run and the low-priority Thread will never release the lock, thus resulting in a deadlock.\item complex donation - test with four Threads and two locks. Mid-priority Thread same as above. Hi-priority and highest-priority Thread each deal with one lock, while low-priority Thread deals with all locks. First, low-priority Thread acquires both locks. Highest-priority Thread should donate priority to hi-priority Thread, which in turn donates to low-priority Thread. Otherwise, deadlock occurs.\end{enumerate}\end{document}