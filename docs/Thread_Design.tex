\documentclass[a4paper,10pt]{article}\usepackage{graphicx}\usepackage{wasysym}\title{Threads Extension for NachOS Implemented~in~Java}\author{Zsolt Istv\'{a}n, Bal\'{a}zs Karsay, Robert Mynio, Istv\'{a}n Szak\'{a}ts}\date{October 2, 2010}\begin{document}\maketitle\section{Alarm Clock}The alarm clock's waitUntil method is implemented by putting the thread to sleepafter registering an event to wake it up after the desired number of ticks.The timerInterrupt method is used to check periodically for any threads thatneed to be woken up i.e the events of which have a wake-up-time greater or equal to thecurrent machine time. In order to efficiently access the events in the order oftheir wake-up-time, a priority queue consisting of entries of type AlarmEntrywhich records the time and the thread to wake up. This data structureensures O(1) time when comparing the event with the smallest time with the currenttime, O(log n) time when one or more elements need to be removed during a tickand O(log n) when inserting new elements into the queue. To achieve synchronization between adding and polling/removing elements from the priority queue, interrupts are disabled and the restored in both the waitUntil and timerInterrupt method.\begin{verbatim}class AlarmEntry {  public long time;  public KThread thread;}	private PriorityQueue<AlarmEntry> queue;\end{verbatim}\subsection{Testing}The alarm clock can be tested by creating a thread, having it put itself to sleep and printthe time before and after the sleep. Its also good to have another thread keep running in thebackground and check if the context switched to it when the first thread went to sleep. Totest synchronization, many instances of waitUntil should be issued and at least on real hardwarethe problems should turn up if there are any.\pagebreak\section{Condition Variables}Condition variables can be implemented in the following way:\begin{itemize}\item sleep	\begin{verbatim}	release lock -- so that other threads can 	                acquire the variable for changing	disable interrupts -- ensure synchronization with 	                      the wake/wakeAll methods	insert current thread into thread queue -- the lock's 	                                           own thread queue 	                                           cannot be used	put the thread to sleep -- until woken up	restore interrupts	acquire lock	\end{verbatim}\item wake	\begin{verbatim}	disable interrupts	if queue not empty	  get the next thread from the queue -- according to whatever 	                                        policy the scheduler has	  put that thread in a ready state	  remove that thread from the queue	restore interrupts	\end{verbatim}\item wakeAll -- Same as wake but keep waking up threads / removing elements from the queue until it is empty.\end{itemize}\subsection{Testing}The condition variables can be tested by creating threads which wait for certain variablesto changes and others which make it change and then checking if the threads are woken up as they should be.\section{Thread Joining}Joining threads can be implemented in many ways but care must be taken to avoid the possible race conditions.One of the easiest methods is to have a lock that is acquired by the thread when it is created and released when it is finished. When a thread wishes to join it does an acquire followed by a release on the same lock. Thus any joining thread will wait on the lock until the thread finishes and if multiple threads are waiting, each on will restore the lock to a released state for the next one. To avoid the race condition on when checking whether the thread has already finished, interrupts should be disabled before it. They are also disabled during finish so that is enough.\begin{itemize}\item thread start: \texttt{acquire lock, status = running}\item thread finish: \texttt{status = finished, release lock}\item thread join:	\begin{verbatim}	disable interrupts 	if state != finished	  acquire lock	  release lock	restore interrupts	\end{verbatim}\end{itemize}\subsection{Testing}Thread joining can be tested by creating a thread and having multiple other threads join it at the same time and see if they all exitthe join at the same time as the thread finishes. \section{Synchronization}\subsection{Communicator}The role of the communicator is to allow threads to synchronously exchange messages. Multiple threads can be waiting to speak and multiple threads can be waiting listen. There should never be a time when both a speaker and a listener are waiting. The implementation should use condition variables, not semaphores. The condition variables are implemented in the Condition2 class.The Communicator works on the following principle: speak() atomically waits until listen() is called on the same Communicator object, and then transfers the word over to listen. Similarly, listen() waits until speak() is called, at which point the message transfer is made, and both threads can return.Implementation:To assure that the speak() and listen() are executed atomically, each should acquire a lock at entry, and release it after the execution of the method. In order to allow multiple senders and to make sure that no message is lost, each sender must check that there isn't already a message waiting to be read. This is implemented using a condition variable. If there are no unconsumed messages, the sender can place the message in the buffer, after which it will notify all the listeners waiting for a message. Finally, send() will release the lock.On the listener side, after acquiring the lock the method checks if there is a message that is ready to be consumed. If there is no such message, the listener must wait for one. This is implemented with waiting on a condition variable. After a sender places a message in the buffer, it notifies the listeners which will consume the message. Then the method must notify all the threads waiting to send their messages. Finally, listen() can release the lock.In the following, the pseudocode of the methods is presented:\begin{verbatim}BEGIN send(message)  WHILE(messageBuffer not empty) DO    allowSpeak.sleep()  END WHILE  lock.acquire()  messageBuffer = message  allowListen.wakeAll()  lock.release()ENDBEGIN receive()  WHILE(messageBuffer empty) DO    allowListen.sleep()  END WHILE  lock.aquire()  message = messageBuffer  empty messageBuffer  allowSpeak.wakeAll()  lock.release()  RETURN messageEND\end{verbatim}The implementation uses a lock, and two condition variables. The methods sleep() and wakeAll() are implemnted in the Condition2 class. To use the communicator class, two threads should use the same Communicator instance, and simply call the speak and listen methods on it.\subsection{Testing}To test the communicator, a first step would be to make sure that it works with a single sender and single listener thread. After this test, the possibility to use the Communicator class with multiple senders and listeners should be tested.\section{Priority Scheduling}\subsection{Problem description}Our task is to implement a priority scheduler in NachOS by completing the PriorityScheduler class. Priority scheduling is an important detail in any real operating system. The basic idea behind priority scheduling is that in choosing which thread to dequeue, the scheduler should always choose the thread with the highest effective priority. If multiple threads with the same highest priority are waiting in the queue, the scheduler should choose the one that has been waiting the longest.An issue which we have to deal with is priority inversion. If a high priority thread needs to wait for a low priority thread (for instance, for a lock held by a low priority thread), and another high priority thread is on the ready list, then the high priority thread will never get the CPU because the low priority thread will not get any CPU time. Based on the techniques learned at class we decided to solve this issue by using priority donation. That is, to have the waiting thread donate its priority to one which is holding the lock, so this one can execute and release the lock.The current implementation does not deal with the concept of priority, so in order to be able to use the above presented algorithm, we have to extend the notion of a thread. This will be done by including a thread's priority (something that is decided at creation) and a way for deciding its effective priority (which reflects the results of priority donation among threads).\subsection{The ThreadState} A thread's effective priority can be cached in its ThreadState. When the threads in a ThreadQueue change, the effective priority of its owner, say thread A, may also change and may need to be updated.  This will go on .... So updating effective priority is a propagation of these changes.As described before we will have to wrap the KThread objects in a more complex data structure so the system can associate with each thread additional info necessary for priority scheduling. This is what the ThreadState class is for, and these are its most important properties:\begin{itemize}\item priority - which is an integer showing how important a thread is in the system\item effective priority - this value overrides the priority temporarily in case of priority donation, and is cached \item owned queue - this is a reference to the lock whose queue this thread has acquired\end{itemize}From an implementation point of view, it will contain the following methods:\begin{itemize}\item \texttt{get/setPriority()} methods will be used to set and get the priority of the underlying thread.\item \texttt{get/setEffectivePriority()} will be used in the priority donation algorithm together with the \texttt{refreshEffectivePriority()} which will make sure that the effective priority is up to date in a case of waiting for access on a lock. As an example, one could have a thread A that may be added into another ThreadQueue which may have an owner, thread B, and this change may cause B's effective priority to change as well. One has to make sure that this change is correctly propagated.\item \texttt{acquire(queue)} and \texttt{rewokeOwnership()} pair will help setting and clearing the ``owned queue'' mentioned above, and they will be called from the PriorityQueue, whenever it changes owners.\end{itemize}\subsection{The PriorityQueue}PriorityQueue, basically any ThreadQueue, implements the scheduling of threads waiting for accessing any resource, be it the CPU or a lock. There will be a PriorityQueue for each resource. At any time a thread is in exactly one queue (waiting for accessing a resource). Each resource can be held by at most one thread, which we call the owner of that resource (this ownership is referenced also from the ThreadState). Since each resource is associated with one ThreadQueue, the owner of the resource is also called the owner of the ThreadQueue that is waiting for this resource.As with any queue the most important detail of PriorityQueue is the way it gives us the next element, which in our case is based on the priority of the threads. In the following we present the pseudocode for selecting the next thread from the queue:\begin{verbatim}BEGIN selectNext()  IF queue.empty THEN     RETURN null   END IF  priority = priority.MAX  WHILE (queue.getFifo(priority).empty) DO    priority--  END WHILE  fifo = queue.getFifo(priority)  RETURN fifo.removeNextEND\end{verbatim}And the method for inserting a new element into the waiting queue can be described as:\begin{verbatim}BEGIN insert(thread)  IF NOT EXIST queue.getFifo(thread.priority) THEN     queue.createFifo(thread.priority)   END IF  queue.getFifo(thread.priority).add(thread)END\end{verbatim}In order to accomplish the tasks presented above, the ThreadQueue must be subclassed in order to represent additional information required by the priority donation algorithm. The PriorityQueue subclass will contain the following additional properties and data structures:\begin{itemize}\item owner thread - a KThread which is the owner of the PriorityQueue instance.\item waiting threads - this is a HashMap data structure that associates a list of ThreadStates with a given priority.\item priority transfer flag - a boolean which specifies if the owner thread should receive a priority from a waiting thread (priority donation).\end{itemize}From an implementation point of view, it will contain the following methods:\begin{itemize}\item \texttt{getOwnerThreadState()} returns the ThreadState of the owner thread (myThread).\item \texttt{putToWait(ThreadState)/removeFromWait(ThreadState)} pair will be used to add/remove a ThreadState and its associated priority to the HashMap. If a list with the respective priority does not yet exist, it will be created and the ThreadState will be inserted into the list. \item \texttt{acquire(thread)} is used to set the owner of a PriorityQueue.\item \texttt{peekNextThread()} method returns the Thread that \texttt{nextThread()} would return, but it does not change the state and contents of the queue.\item \texttt{nextThread()} selects extracts the next Thread from the queue based on its priority (the thread with the highest priority will be extracted). This method is called when we need to context switch to another thread. We also use this method to restore the effective priority to be equal to its actual priority in case it was changed due priority.\end{itemize}\subsection{Testing}In order to test the functionality of the PriorityScheduler, the following test cases should be implemented:\begin{enumerate}\item no donation - test with at least three Threads with different priorities and no locks. Thus, no priority donation is necessary.\item simple donation - simple priority donation test with three Threads and one lock. A mid-priority Thread that doesn't deal with any locks, a low-priority Thread that deals with the lock and a hi-priority Thread that also deals with the lock. First, the low-priority Thread acquires the lock. Then hi-priority Thread should also acquire the lock. If the priority donation is not implemented correctly, only the hi-priority Thread will run and the low-priority Thread will never release the lock, thus resulting in a deadlock.\item complex donation - test with four Threads and two locks. Mid-priority Thread same as above. Hi-priority and highest-priority Thread each deal with one lock, while low-priority Thread deals with all locks. First, low-priority Thread acquires both locks. Highest-priority Thread should donate priority to hi-priority Thread, which in turn donates to low-priority Thread. Otherwise, deadlock occurs.\end{enumerate}\section{Work Distribution}\begin{itemize}\item Zsolt Istv\'{a}n - Next thread logic in Priority Scheduler; simple test case\item Bal\'{a}zs Karsay - Communicator; test cases\item Robert Mynio - ThreadState effective priority logic; complex test cases\item Istv\'{a}n Szak\'{a}ts - Thread joining, Alarm clock\end{itemize}\end{document}